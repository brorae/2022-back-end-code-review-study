# 1. ResultView와 OutputView
- [코멘트링크](https://github.com/woowacourse/java-chess/pull/308/files/74e9e81825b8504965accecf67055ee626d008d5#r837385702)
```
 public static void printStartMessage() {
        System.out.println("> 체스 게임을 시작합니다.");
        System.out.println("> 게임 시작 : start");
        System.out.println("> 게임 종료 : end");
        System.out.println("> 게임 현황 : status");
        System.out.println("> 게임 이동 : move source위치 target위치 - 예. move b2 b3");
    }
```
- 체스 게임을 시작할 때 시작 메시지를 출력하는 메소드이다.
- 처음에 Class 이름 ResultView에서 이 메소드를 정의하였다.
- 하지만 시작 메지를 출력하는 것은 결과로 보기 힘들 수도 있다.
- 따라서 ResultView를 OutputView로 이름을 수정하였다.

# 2. 상수의 이름은 포괄적인 이름 말고 구체적인 이름을 사용하자.
- [코멘트링크](https://github.com/woowacourse/java-chess/pull/308/files/74e9e81825b8504965accecf67055ee626d008d5#r837390666)


# 3. List의 중첩구조 대신 일급컬렉션을 사용하자.
- [코멘트링크](https://github.com/woowacourse/java-chess/pull/308/files/74e9e81825b8504965accecf67055ee626d008d5#r837396855)

- 일급컬렉션을 사용하면 가독성이 높아진다.
- 책임을 분리할 수 있다.

# 4. 적절한 띄어쓰기와 메서드 분리로 가독성을 높이자.
- [코멘트링크](https://github.com/woowacourse/java-chess/pull/308/files/74e9e81825b8504965accecf67055ee626d008d5#r837415342)
- 변경 전
```
public void move(GameCommand gameCommand) {
        Position from = gameCommand.getFromPosition();
        Position to = gameCommand.getToPosition();
        Piece piece = selectPiece(from);
        Map<Direction, List<Position>> movablePositions = piece.getMovablePositions(from);
        refinePawnMovablePositions(from, piece, movablePositions);
        List<Position> finalMovablePositions = generateMovablePositionsWithBlock(from, piece, movablePositions);
        checkMovable(to, finalMovablePositions);
        movePiece(from, to, piece);
    }
```
- 변경 후
```
public void move(GameCommand gameCommand) {
    Position from = gameCommand.getFromPosition();
    Position to = gameCommand.getToPosition();

    Piece piece = selectPiece(from);
    List<Position> finalMovablePositions = getMovablePositions(from, piece);

    checkMovable(to, finalMovablePositions);
    movePiece(from, to, piece);
}
```

# 5. final 클래스로 선언된 클래스에서는 메서드에 final을 붙일 필요가 없다.
- [코멘트링크](https://github.com/woowacourse/java-chess/pull/308/files/74e9e81825b8504965accecf67055ee626d008d5#r837413056)

# 6. 일관성 있게 코드를 작성하자.
- [코멘트링크](https://github.com/woowacourse/java-chess/pull/308/files/74e9e81825b8504965accecf67055ee626d008d5#r837424940)
- 변경 전
```
...
import org.assertj.core.api.Assertions;
...


@Test
@DisplayName("32개의 체스말들을 생성한다")
void generate() {
    PiecesGenerator piecesGenerator = new NormalPiecesGenerator();
    Map<Position, Piece> pieces = piecesGenerator.generate();
    Assertions.assertThat(pieces).hasSize(32);
}
```
- 다른 테스트에서는 import static으로 사용했지만, 페어프로그래밍을 하면서 미쳐 발견하지 못한 부분이 있었다.
- 변경 후
```
...
import static org.assertj.core.api.Assertions.assertThat;
...

@Test
@DisplayName("32개의 체스말들을 생성한다")
void generate() {
    final PiecesGenerator piecesGenerator = new NormalPiecesGenerator();
    final Map<Position, Piece> pieces = piecesGenerator.generate();

    assertThat(pieces).hasSize(32);
}
```
- 추가적으로 단언문과 이전의 준비과정을 띄어쓰기로 구분하면 가독성이 높아진다.
